\subsection{fulibWorkflows}\label{subsec:fulibworkflows}
Bei~\textit{fulibWorkflows} handelt es sich um eine Java-Bibliothek, welche Workflows in YAML\footnote{Kurzform von ``YAML Ain't Markup Language''}-Syntax notiert,
als Eingabe erhält und daraus
sowohl ein \ac{ES}-Board als auch im Workflow beschriebene Mockups und Objekt-/ Klassendiagramme generiert.
Welche Form die YAML-Eingabe haben muss und wie die Dateien aussehen und generiert werden, wird in Kapitel~\ref{subsec:workflow-format} erläutert.

\input{chapter/2/2.2.1.1.antlr}

\subsubsection{StringTemplate}
Die Java-Bibliothek \textit{StringTemplate} gehört, wie das vorherige~\ac{Antlr}, zum~\textit{Antlr Project}.
\ac{Antlr} verwendet ebenfalls String-Templates zur Generierung von formatiertem Text, im Folgenden als \textit{Code} bezeichnet.
Templates (übersetzt: Schablonen) ermöglichen es zum Beispiel die feste Syntax einer Programmiersprache mit variablen Werten für
Variablen, Klassen und Methoden zu belegen.
Somit können die generellen Bausteine einer Sprache beliebig gefüllt werden.
Durch diese Funktionalität bieten sich \acp{ST} sehr gut zur Generierung von Dateien an.
Ursprünglich ist \textit{StringTemplate} eine Java-Bibliothek, jedoch wurden bereits Portierungen für C\#, Objective-C, JavaScript und Scala erstellt.

Die folgenden Erläuterungen beziehen sich jedoch auf die ursprüngliche Java-Version von~\textit{StringTemplate}, da diese in dieser Arbeit verwendet wird.
Die einfachste Möglichkeit für die Verwendung eines String Templates ist in Listing~\ref{listing:simpleTemplate} zu sehen.

\begin{listing}[!ht]
    \inputminted{java}{listings/2.2.1/JavaStringTemplateExample.java}
    \caption{``Hello World!'' - Beispiel mittels StringTemplate}
    \label{listing:simpleTemplate}
\end{listing}

Die Klasse \textit{ST} aus Zeile 3 kann mit einem String initialisiert werden.
In diesem Beispiel wurden als Begrenzer für das zu ersetzende Stück des Textes die Zeichen ``<''  und ``>'' verwendet.
Im Anschluss wird dem neuen \textit{ST}-Objekt mithilfe der add()-Methode ein bestimmter Wert hinzugefügt.
Der erste Parameter der Methode ist der Bezeichner innerhalb eines Templates, zu beachten ist die Angabe des Bezeichners ohne die Begrenzer.
Der Wert wird als zweiter Parameter übergeben und besitzt in diesem Beispiel den Text~\textbf{World}.
Um nun den fertig ersetzten Text aus dem Template und dem übergebenem Wert zu bekommen, muss auf dem \textit{ST}-Objekt die Methode render() aufgerufen werden.
Hierbei werden die Platzhalter des Templates durch den zuvor übergebenen Wert ersetzt und als String zurückgegeben.
In Zeile 6 wird nun abschließend der fertige Text ``Hello, World!''  auf der Konsole ausgegeben.
Dieses Beispiel entstammt der offiziellen Webseite von~\textit{StringTemplate}\cite*{stOrg}.

Für ein strukturiertes Arbeiten mit vielen Templates bietet \textit{StringTemplate} die Möglichkeit \acp{STG} zu erstellen.
Hierbei können mehrere Templates in einer Datei beschrieben werden, um aufeinander aufbauende Templates nicht im Code, sondern einer gesonderten Datei zu organisieren.
In diesen Dateien, welche die Dateiendung \textbf{.stg} tragen, können die Begrenzer (eng.: Delimiters) frei gewählt werden.
Dies ist je nach Kontext des Templates nötig, da zum Beispiel die Generierung von HTML-Dateien, welche ``<''  und ``>'' als Zeichen zum Abgrenzen von Bereichen verwenden,
mit den Standard-Begrenzern für einen Mehraufwand sorgt.
Bei der Wahl der Begrenzer sollte somit stets auf die Wahl der Zeichen im Kontext der zu generierenden Sprache geachtet werden.
Zum Parsen einer \ac{STG} wird ein mit \ac{Antlr} generierter Parser verwendet\cite*{stgParser}.

\begin{listing}[ht]
    \inputminted{c}{listings/2.2.1/Example.stg}
    \caption{Beispiel einer .stg-Datei}
    \label{listing:stgFile}
\end{listing}

Wie zuvor beschrieben ist in Listing~\ref{listing:stgFile} zu erkennen, dass in Zeile 1 die Begrenzer auf ``\{'' und ``\}'' gesetzt wurden.
Dies hat den Hintergrund, dass in diesem Beispiel ein Text in eine HTML-Datei generiert werden soll.
Hierfür könnten auch die Standard-Begrenzer verwendet werden, allerdings müssten dann für Schlüsselwörter wie~\texttt{<span>} die Zeichen ``<'' und ``>'' mit einem führenden Backslash definiert werden.
Da dies für HTML-Dateien allerdings einen immensen Aufwand bedeutet, ist die Nutzung anderer Begrenzer sinnvoll.
In Zeile 3 werden für ein~\ac{ST} sowohl der Name des Templates als auch Übergabeparameter definiert.
Ein~\ac{ST} wird durch ``> >'' geschlossen.
Die Begrenzer in Zeile 5 zeigen, dass alles, was sich zwischen Ihnen befindet, einen Übergabeparameter in sich trägt.
Somit ist das Wiederverwenden des Templates und die variable Befüllung gewährleistet.

Um diese Templates nun in einem Java-Programm zu verwenden, benötigt es unter anderem die zuvor beschriebene ST-Klasse, sowie
die Klasse~\textit{STGroupFile}, welche für die Verwaltung der stg-Datei als auch deren Templates, benötigt wird.
In Zeile 6 von Listing~\ref{listing:stgJavaFile} ist zu erkennen, dass einem STGroupFile-Objekt bei der Initialisierung eine URL übergeben werden muss.
Diese URL verweist auf die stg-Datei.
Im Anschluss kann, wie in Zeile 8 ersichtlich, über die getInstanceOf()-Methode auf ein bestimmtes Template in der stg-Datei zugegriffen werden.
Hierbei ist es wichtig, dass der übergebene Bezeichner der getInstanceOf()-Methode mit dem Bezeichner in der stg-Datei übereinstimmt.
Schließlich ist die weiterführende Verwendung bereits zuvor mittels der ST-Klasse beschrieben worden.

\begin{listing}[!ht]
    \inputminted{java}{listings/2.2.1/JavaSTGExample.java}
    \caption{Nutzung einer STG-Datei in Java}
    \label{listing:stgJavaFile}
\end{listing}

Bei der Ausführung dieses Beispiels wird auf der Konsole der Text aus Listing~\ref{listing:outputSTG} angezeigt.

\begin{listing}[!ht]
    \begin{minted}{html}
<span>
    This test about the university is written in english.
</span>
    \end{minted}
    \caption{STG-Ausgabe auf Konsole}
    \label{listing:outputSTG}
\end{listing}

\subsubsection{JSON-Schema}\label{subsubsec:json-schema}
JSON-Schemas, von der gleichnamigen Organisation ``JSON Schema'' entwickelt, geben die Struktur und den Inhalt einer JSON-/YAML-Datei vor\cite*{jsonSchema}.
Hierdurch ist es möglich, den Nutzer in seinen Eingaben zu begrenzen und bereits während des Schreibens einer Datei dabei zu unterstützen sinnvolle Eingaben zu erstellen.
Mittels JSON-Schemas werden unter anderem Konfigurationsdateien spezifiziert, wodurch Standards zur Übertragung von Daten mittels JSON-Dateien ermöglicht wird.

JSON-Schemas können Objektstrukturen in beliebiger Tiefe schachteln.
Im folgenden Abschnitt werden die grundlegenden Elemente eines JSON-Schemas erläutert.
Weiterführende Funktionalitäten werden anhand der Implementierung in Kapitel~\ref{subsec:schema} näher beleuchtet.

Ein einzelnes Objekt kann zur Verbesserung der späteren Nutzung mit einem Titel und einer kurzen Beschreibung versehen werden.
Diese sind in Listing~\ref{listing:objectSchema} in Zeile 2 und 3 dargestellt.
Die Einträge \textit{title} und \textit{description} dienen lediglich der verbesserten Lesbarkeit für den Entwickler.

\begin{listing}[!ht]
    \inputminted{json}{listings/2.2.1/object.schema.json}
    \caption{Objekt-Beispiel eines JSON-Schemas}
    \label{listing:objectSchema}
\end{listing}

Einem Element muss stets ein~\textit{type}, also ein Typ, zugeordnet werden.
Dies kann entweder ein Objekt, Zeile 4 in Listing~\ref{listing:objectSchema}, oder eine Liste sein.
Einem Objekt können nun \textit{properties} hinzugefügt werden.
Diese besitzen neben einem eindeutigen Bezeichner ebenfalls eine Beschreibung und einen Typen.
Auf dieser Ebene kann der Typ eine Nummer, \textit{integer} in Zeile 8, oder auch ein Text, welcher den Typ \textit{string} bekommen würde, sein.
Ist eine der \textit{Properties} ein notwendiges Feld, kann dies mittels des Schlüsselwortes \textit{required} realisiert werden.
Hierbei wird eine Liste an Bezeichnern hinterlegt, welche dem Objekt bereits zugeordnet wurden und somit stets vorhanden sein müssen.
Das Beispiel stammt von der offiziellen JSON-Schema-Webseite\cite*{schemaExample}.
Sollten einem Objekt keine weiteren properties hinzugefügt werden dürfen, ist dies mit dem Ausdruck aus Listing~\ref{listing:additionalProperties} möglich.

\begin{listing}[!ht]
    \begin{minted}{json}
"additionalProperties": false
    \end{minted}
    \caption{Begrenzung der Properties eines Schemas}
    \label{listing:additionalProperties}
\end{listing}

Wie zuvor bereits beschrieben, kann ein Element auch als Liste deklariert werden.
Dies ist an einem kleinen Beispiel in Listing~\ref{listing:listSchema} dargestellt.
Hierbei ist es möglich die \textit{items} einer Liste genauer zu definieren.
In diesem Beispiel müssen die Elemente einer Liste dem Schema aus dem Beispiel aus Listing~\ref{listing:objectSchema} entsprechen.

Eine JSON- oder YAML-Datei, welcher dieses Schema zugrunde liegt, besteht somit aus einer Liste an Produkten.
Durch die Verwendung des \textit{oneOf}-Operators in Zeile 6 werden nur Elemente mit dem darunterliegenden Schema akzeptiert.
Bei mehreren Einträgen in der \textit{items} Aufzählung muss immer eines dieser Elemente auf das Objekt in der JSON-/YAML-Datei zutreffen.

\begin{listing}[!ht]
    \inputminted{json}{listings/2.2.1/list.schema.json}
    \caption{Listen-Beispiel eines JSON-Schemas}
    \label{listing:listSchema}
\end{listing}

Durch ein fest definiertes Schema ist es vielen IDEs, darunter auch IntelliJ und VSCode,
möglich den Entwickler durch Fehlerhervorhebung und Autovervollständigung zu unterstützen.
Hierfür ist es möglich bereits erstellte JSON-Schemas im \textit{SchemaStore} bereitzustellen.
Dies ist eine zentrale Stelle, um JSON-Schemas für IDEs zur Verfügung zu stellen.
Bei dem \textit{SchemaStore} handelt es sich um ein Open-Source-Projekt, bei welchem die Einbringung eines neuen Schemas simpel gestaltet ist.
Es ist möglich ein fertiges Schema fest dort zu hinterlegen, hierdurch muss für jede neue Änderung allerdings ein neuer Pull Request erstellt werden.
Dieser bedarf einer Zustimmung einem der Verwalter des~\textit{Schema Stores}.
Da dies stets mit einer Verzögerung passiert, ist es möglich eine Verlinkung zu einem Schema zu erstellen.
Somit können Änderungen an einem Schema durchgeführt werden, um diese Änderungen nach dem Hochladen direkt zur Verfügung stellen zu können.
Zum aktuellen Zeitpunkt existieren 439 Schemas, welche durch \textit{SchemaStore.org} für diverse IDEs\footnote{\url{https://www.schemastore.org/json/#editors}}
bereitgestellt werden\cite*{schemaStore}.

\subsubsection{fulibTools}
\todo{Für jemanden der Fulib nicht kennt ist das hier einfach Brainfuck oder? Mit Seb abklären, ob das stark genug genutzt wurde um es hier in vermutlich doppelter
Länge richtig zu beschreiben}

FulibTools ist Teil der Fujaba Tool Suite.
Auch das in dieser Arbeit erstellte fulibWorkflows ist ein Teil der Fujaba Tool Suite.
Fulib bildet die Grundlage für fulibTools, wobei fulibTools erweiterte Möglichkeiten für die Nutzung von fulib bereitstellt.
Fulib ist ein Codegenerator, welcher mittels einer~\ac{DSL} Modelle als Diagramme darstellen kann\cite*{fulib}.
Dies begrenzt sich nicht nur auf Klassenmodelle, sondern ist auch für Objektmodelle einsetzbar.
FulibTools ist eine Erweiterung, da die Generierung der Diagramme auch abseits der eben erwähnten DSL funktioniert\cite*{fulibTools}.
Hierdurch bietet sich die Möglichkeit Objektmodelle über ein spezielles YAML-Format oder ein Java-Objektmodell zur Laufzeit zu generieren.
Gleiches gilt für Klassenmodelle.
Die Verwendung von FulibTools ist somit für diese Arbeit eine bessere Wahl als~\textit{Graphviz}, eine Bibliothek zur Generierung von Diagrammen, direkt zu verwenden.
Dies ist der Fall, da FulibTools bereits die Verarbeitung einer Eingabe übernimmt und hierdurch leichter für ein weiteres Tool der Fujaba Tool Suite zu verwenden ist.
