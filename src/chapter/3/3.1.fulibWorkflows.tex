\section{fulibWorkflows}\label{sec:fulibworkflows2}
\textit{fulibWorkflows} ist eine Java-Bibliothek, welche Workflow Beschreibungen als Eingabe bekommt, diese Eingabe
selbst parst und daraus HTML-/FXML-Mockups, Objektdiagramme und Klassendiagramme generiert.
Das Parsen wird über einen von Antlr generierten Parser übernommen, hierzu wird in Kapitel~\ref{subsec:fulibworkflows-grammatik} genauer auf
die zugrundeliegende Grammatik eingegangen.
Zudem wird auf die Limitationen des Parsers und der generierten Mockups eingegangen.

\input{chapter/3/3.1.1.format}

\subsection{JSON-Schema}\label{subsec:schema}
Wie im vorherigen Kapitel bereits erwähnt bedient sich die Beschreibung eines Workflows grundlegend der Syntax von~\ac*{YAML}.
In Kapitel~\ref{subsubsec:json-schema} wurden bereits die Grundlagen für JSON-Schemas geschaffen, in diesem Kapitel wird das erstellte
fulibWorkflows-Schema genauer betrachtet.
Das Schema ist komplett im Anhang hinterlegt, da dieses zu lang ist um es übersichtlich in diesem Kapitel zu erläutern.
Dadurch wird nur auf die wichtigsten Punkte der Implementierung eingegangen.
Um die Lesbarkeit für Entwickler zu verbessern, ist das Schema in zwei Dateien aufgeteilt.

\begin{listing}[!ht]
    \inputminted[xleftmargin=20pt,linenos]{json}{listings/3.1/page.json}
    \caption{Referenzieren eines anderen Schemas}
    \label{listing:schema-split}
\end{listing}

Listing~\ref{listing:schema-split} ist eine minimale Version des eigentlichen Schemas, in welchem dennoch die wichtigsten Funktionen dargestellt sind.
Das fulibWorkflows-Schema ist in zwei Hauptteile unterteilbar, in die Definitionen und die Festlegung der erlaubten Elemente in der obersten Liste.
Durch das Schema werden nur JSON-/YAML-Dateien akzeptiert, welche aus einer Liste an Elementen bestehen.
Hierbei sind die Elemente jedoch festgelegt durch die in Zeile 20 und 21 dargestellten Zeilen.
Ein \textit{item} darf nur aus einem der Elemente bestehen, welche in der Auflistung ab Zeile 22 festgelegt sind.
Um die Lesbarkeit zu vereinfachen und die Schachtelungstiefe möglichst gering zu halten, werden die erlaubten Elemente lediglich referenziert.
Die referenzierten Elemente wurden im ersten Teil des Schemas, ab Zeile 4, definiert.
Für jedes der im vorherigen Kapitel erwähnten Zettel, gibt es ein Element im Schema.
Die Definitionen der Elemente, welche nicht in Listing~\ref{listing:schema-split} dargestellt sind, enthalten lediglich Standardwerte, welche bereits in Kapitel~\ref{subsubsec:json-schema} erläutert wurden.
Diese können im Anhang nachgelesen werden.
Die Definition der Page ist jedoch ein Sonderfall, welche durch das Aufteilen in mehrere Dateien entstanden ist.
Es ist möglich weitere Schemas aus einer anderen Datei zu importieren, dies ist in Zeile 11 ersichtlich.
Auch dort wird erneut eine Referenzierung durchgeführt, allerdings nicht auf eine im Schema befindlichen Definition, sondern auf die Page Definition aus der \textit{page.schema.json} Datei.
Die Aufteilung wurde durchgeführt, da die Page eine Liste ist und ebenfalls fünf eigene Elemente definiert.
Allein das Page-Schema beläuft sich auch 93 Zeilen und umfasst somit allein die Hälfte des Parent-Schemas.

Wie in Kapitel~\ref{subsubsec:json-schema} bereits erwähnt, ist das fulibWorkflows-Schema ebenfalls bei Schemastore.org hinterlegt.
Es wird automatisch für Dateien mit der Dateiendung \textit{.es.yaml} vom Editor verwendet.
Dadurch ist es zum Beispiel in IntelliJ möglich Autovervollständigung für fulibWorkflows zu bekommen und auf Fehler hingewiesen zu werden.

\begin{figure}%
    \centering
    \subfloat[\centering Leere Datei]{{\includegraphics[width=6cm]{images/3.1/Empty} }}%
    \qquad
    \subfloat[\centering Fehlerhafte Eingabe]{{\includegraphics[width=7cm]{images/3.1/fails} }}%
    \caption{Fehleranzeige in IntelliJ}%
    \label{fig:errors-schema}%
\end{figure}

In Abbildung~\ref{fig:errors-schema} ist das Hervorheben von Fehlern in IntelliJ dargestellt, welches durch das JSON-Schema generiert wird.
In Abbildung~\ref{fig:errors-schema}((a)) ist die Datei leer, wodurch die Schema Validierung anschlägt und den Entwickelnden darauf hinweist, dass ein Array, also eine Liste an Elementen, benötigt wird.
Sobald ein Element begonnen wird, wird diese Warnung nicht mehr angezeigt.
Sollte der Entwickelnde wiederum ein Element hinzufügen, welches keinem der definierten Elemente des Schemas entspricht, wird die Meldung aus Abbildung~\ref{fig:errors-schema}((b)) angezeigt.
Da ein Command keine zusätzlichen Attribute/Properties akzeptiert, dennoch eines hinzugefügt wurde, besagt der Fehler, dass es nicht erlaubt ist weitere Attribute hinzuzufügen.

\begin{figure}%
    \centering
    \subfloat[\centering Alle Elemente]{{\includegraphics[width=6cm]{images/3.1/all} }}%
    \qquad
    \subfloat[\centering Page Elemente]{{\includegraphics[width=6cm]{images/3.1/page} }}%
    \caption{Autovervollständigung in IntelliJ}%
    \label{fig:completion-schema}%
\end{figure}

Wie zuvor erwähnt ermöglicht ein Schema jedoch nicht nur das Hervorheben von Fehlern, sondern unterstützt den Entwickelnden zusätzlich durch Autovervollständigung.
Dies ist in Abbildung~\ref{fig:completion-schema} dargestellt.
Hierbei wird aufgrund des Kontextes verschiedene Möglichkeiten von zu erstellenden Elementen vorgeschlagen.
Auf oberster Ebene werden alle erlaubten Schlüsselwörter für Elemente angezeigt, welches in Abbildung~\ref{fig:completion-schema}((a)) dargestellt ist.
Hierbei fällt auf, dass die Elemente für eine Page nicht angezeigt werden, dies ist jedoch der Fall, sobald der Kontext dies zulässt.
Während der Entwickelnde ein page-Element definiert, werden wie in Abbildung~\ref{fig:completion-schema}((b)) dargestellt die Schlüsselwörter für Page-Elemente vorgeschlagen.

\subsection{Antlr Grammatik}\label{subsec:antlr-grammatik}
Da die möglichen Eingaben durch das zuvor beschriebene JSON-Schemas bereits verringert wurden, viel die Wahl der Verarbeitung der YAML-Eingabe auf eine durch Antlr generierten Parser.
Der generierte Parser bietet die Möglichkeit, während dem parsen weitere Aktionen durchzuführen und in dem Fall dieser Anwendung ein Datenmodell aus der Eingabe zu erstellen.
Das Datenmodell wird im folgenden weiterverarbeitet und bietet somit eine Grundlage für die Generierung, auf welche im folgenden Kapitel eingegangen wird.

Wie in Kapitel~\ref{subsubsec:antlr} bereits beschrieben, ist die Grundlage eines Antlr Parser die dazugehörige Grammatik, welche nun beleuchtet wird.
Die komplette Grammatik ist im Anhang hinterlegt, in diesem Kapitel werden lediglich Ausschnitte daraus verwendet.

\begin{listing}[!ht]
    \inputminted[xleftmargin=20pt,linenos,firstnumber=5]{antlr}{listings/3.1/Main.g4}
    \caption{Grammatik für Workflows}
    \label{listing:main-grammar}
\end{listing}

Zuerst wird die grundlegende Struktur einer Datei festgelegt, dies ist durch die drei Regeln in Listing~\ref{listing:main-grammar} dargestellt.
Da eine Datei mehrere Workflows beinhalten kann, ist die oberste Regel in Zeile 5 der Startpunkt des Parser.
Da als Eingabe eine YAML-Datei ist, heißt die oberste Regel \textit{file} und erfordert mindestens einen workflow.
Ein workflow besteht immer aus einem workflow-Note und beliebig vielen event-Notes, wobei diese immer mit einer Leerzeile von einander getrennt sind.
Die Spezifikation ist aufgrund der YAML-Syntax notwendig.
Ein event-Note kann einer aus drei Typen sein, wobei nach einem Note beliebig viele Leerzeilen folgen können.

\begin{listing}[!ht]
    \inputminted[xleftmargin=20pt,linenos,firstnumber=11]{antlr}{listings/3.1/Note.g4}
    \caption{Grammatik für Notes}
    \label{listing:note-grammar}
\end{listing}

Die Unterscheidung zwischen normal-/extended-Note, workflow und page erfolgt durch das Schlüsselwort, welches zwischen Bindestrich(MINUS) und Doppelpunkt(NAME) befindet.
Sowohl ein workflow-Note als auch die normal-Notes besitzen lediglich nach dem Doppelpunkt einen Wert, welcher durch \textbf{NAME} gekennzeichnet ist.
Dies ist in Listing~\ref{listing:note-grammar} in Zeile 11 und 13 dargestellt.
Ein extended-Note besitzt neben dem Wert zusätzliche Attribute, welche in einer neuen Zeile beschrieben werden.
Die Anzahl der attribute ist beliebig, es ist somit erlaubt einen extended-Note ohne weitere Attribute anzugeben.
Die Page ist wie zuvor bereits häufiger erwähnt ein Sonderfall, welches sich auch in der Grammatik widerspiegelt.
Dem Schlüsselwort \textit{page} folgt ein gesonderter Doppelpunkt und anschließend eine Liste von neuen Elemente.

\begin{listing}[!ht]
    \inputminted[xleftmargin=20pt,linenos,firstnumber=30]{antlr}{listings/3.1/Keywords.g4}
    \caption{Schlüsselwörter zum Identifizieren von Notes}
    \label{listing:note-ids}
\end{listing}

Die zuvor erwähnte \textit{normalen Notes} bestehen wie in Listing~\ref{listing:note-ids} Zeile 30 und 31 dargestellt aus externalSystem, service, command, policy, user und problem.
Diese erhalten lediglich einen Bezeichner und erlauben keine weiteren Attribute.
Zu den \textit{extended Notes} zählen lediglich event und data.
Diese erhalten wie zuvor beschrieben weiter Attribute um Daten, welche zwischen Services verschickt werden, darstellen zu können.

\begin{listing}[!ht]
    \inputminted[xleftmargin=20pt,linenos,firstnumber=19]{antlr}{listings/3.1/Attribute.g4}
    \caption{Grammatik von Attributen}
    \label{listing:attributes}
\end{listing}

Attribute werden eingerückt und enthalten neben einem Bezeichner(NAME) einen dazugehörigen Wert(value).
Ein Wert kann entweder ein Text, eine Nummer oder eine Liste sein, wobei eine neue Zeile optional ist.
Die dazugehörigen Regeln sind in Zeile 19 und 21 aus Listing~\ref{listing:attributes} vermerkt.

Wie in Listing~\ref{listing:values} genauer beschrieben, ist der akzeptierte Text auf eine feste Zahl an verschiedenen Zeichen begrenzt.
Ein Text muss stets mit einem Buchstaben beginnen, ungeachtet ob groß oder klein geschrieben.
Darauf können Zahlen, Sonderzeichen und weitere Wörter folgen.
Die Sonderzeichen sind in Zeile 36 genauer beschrieben.

\begin{listing}[!ht]
    \inputminted[xleftmargin=20pt,linenos,firstnumber=36]{antlr}{listings/3.1/Values.g4}
    \caption{Grammatik von Werten}
    \label{listing:values}
\end{listing}

Eine Nummer kann lediglich eine ganze Zahl sein, führende Nullen sind erlaubt.
Die Möglichkeit als Wert eine Liste angeben zu können, basiert auf der Möglichkeit Objekt- und Klassendiagramme mit fulibWorkflows generieren zu können.
Hierzu wurde die Syntax von Java als Grundlage genommen.
Zwischen den Klammern in Zeile 38 befindet sich eine sogenannte Wildcard, welche es erlaubt alle Symbole als Eingabe zu akzeptieren.
Die Klammern erfüllen somit nicht nur den Zweck als Listendarstellung, sondern auch die Begrenzung der Wildcard.
Eine Wildcard für die Eingabe eines Textes zu verwenden war für diese Grammatik aufgrund der Struktur vorerst nicht möglich, da es keine passenden Begrenzungen gab,
welche keine anderen Regeln überschrieben hätte.

\begin{listing}[!ht]
    \inputminted[xleftmargin=20pt,linenos,firstnumber=23]{antlr}{listings/3.1/Page.g4}
    \caption{Grammatik einer Page}
    \label{listing:page}
\end{listing}

\todo{Page Grammatik erläutern}

\todo{Was wird beim Parsen zusätzlich gemacht?}

\todo{Ergebnis nach dem Parsen}

\subsection{Mockups}\label{subsec:mockups}
\todo{this}
Eigenes Datenmodell gebaut.
Daraus die wichtigsten Infos gezogen.
Dank StringTemplates von antlr richtig easy zu bauen.
Gilt für Html als auch Fxml.

\subsection{Generierung dank fulibTools}\label{subsec:generierung-dank-fulibtools}
\todo{this}
FulibTools gibt gute Anbindung an Graphviz, wenn man sowieso schon mit fulib arbeitet.
