\chapter{Grundlagen}\label{ch:technologien}
Im folgenden Kapitel werden zuerst die grundlegenden Konzepte des \textit{Event Stormings} erläutert.
Hierbei wird auf dessen Herkunft und Entwicklung eingegangen.
Neben diesen Grundlagen werden anschließend die für diese Arbeit notwendigen Änderungen und Erweiterungen dargelegt.
Weiterhin werden die wichtigsten Technologien erläutert, welche für die Implementierung der Anwendungen nötig waren.
Um eine bessere Übersicht zu schaffen, sind die Technologien nach dem Anwendungsteil, für welche diese nötig sind, unterteilt.

\section{Event Storming}\label{sec:event-storming}
Dieses Unterkapitel befasst sich mit der Herkunft des \textit{Event Stormings}, dem \ac*{DDD}.
Zudem wird ein klassischer Ablauf eines \textit{Event Stormings} erläutert und daran die Vorteile dieser Methodik für das Requirements Engineering beleuchtet.
Abschließend werden die Änderungen und Erweiterungen, welche im Kontext dieser Arbeit vorgenommen wurden, erklärt.

\subsection{Allgemein}\label{subsec:allgemein}
\todo Bevor ich dieses und das folgende Unterkapitel schreibe, erst noch mal das \cite*{dddd} und \cite*{introES} lesen.
\begin{itemize}
    \item Alberto Brandolini und das ES
    \item DDD als Grundlage
    \item Wie verläuft so ein ES Workshop (Beschrieben in seinem Buch, mehrfach)
    \item Wichtigsten Eckpunkte
    \item Warum ist es besser als Brain Storming oder ähnliches?
    \item Beispielhaftes Event Storming Board (Bild und beschreibungstext um später darauf bezug nehmen zu können)
\end{itemize}

\subsection{Erweiterung}\label{subsec:erweiterung}
\todo Hier das vorherige Kapitel abwarten um alle Änderungen/Erweiterungen besser daran fest zu machen.
\begin{itemize}
    \item Erweiterungen für Wirtschaft (Pages -> daraus generierte Mockups, abgehen von dem "Wir wollen keinen PC benutzen" des ES)
    \item Ideen für die Lehre (Wird in dieser Arbeit nicht näher beleuchtet, da es für den Beleg der Funktionalität nicht mehr möglich ist dies ausreichend in der Bearbeitungszeit zu machen)
    \item ES -> Ablauf von Schritten -> Albert -> Workflow (Arbeitsablauf) beschreibungen -> Mögliche Idee zum besseren Nahebringen von komplexeren Abläufen in Vorlesungen. (Verbildlichung)
\end{itemize}

\section{Technologien}\label{sec:technologien}
Dieses Kapitel gibt einen Überblick über die verwendeten Technologien in der Umsetzung.
Da die Implementierung aus veschiedenen Komponenten besteht, ist dieses Kapitel in drei weitere Unterkapitel aufgeteilt.
Es wird somit getrennt auf die Java Library \textit{fulibWorkflows}, das Spring Boot Backend des \textit{fulibWorkflows Web-Editors}
und das zum Editor dazugehörige Frontend, welches mit Angular umgesetzt wurde.

\subsection{fulibWorkflows}\label{subsec:fulibworkflows}
\textit{fulibWorkflows} ist eine Java Library, welche Arbeitsabläufe, im Folgenden "workflows", in \ac*{YAML}-Syntax notiert als Eingabe nimmt und daraus
sowohl ein Event Storming Board, im workflow beschriebene Mockups und Objekt-/ Klassendiagramme generiert.
Welche Form die YAML-Eingabe haben muss und wie die Dateien aussehen und generiert werden, folgt in einem späteren Kapitel.

\subsubsection{Antlr}\label{subsubsec:antlr}
Aus dem Antlr Project wurden zwei verschiedene Bestandteile genutzt. Zum einen die Möglichkeit Parser anhand einer
eigenen Grammatik zu generieren und zum anderen die stringtemplates mit welchem ermöglicht wird Templates für Dateien
zu erstellen und diese dynamisch mit Werten füllen zu können.

\todo ANTLR4


\todo String Templates

\subsubsection{JSON-Schema}\label{subsubsec:json-schema}
Bei einem JSON-Schema kann man die erlaubten Eingaben eines Nutzers, sowohl für JSON-Dateien als
auch YAML-Dateien beschränken.

\todo Welche Version?, Schemastore.org, wie funst das mit den schemas?

Durch ein fest definiertes Schema ist es vielen IDEs, darunter auch IntelliJ und VSCode, welche
aus einem Schema nicht nur die fertige Datei auf Fehler überprüfen, sondern dem Entwickelnden bereits
zum Zeitpunkt des Schreibens einer Datei mittels Autovervollständigung unterstützen kann.
Eine Liste aller IDEs, welche diesen support mittels schemastore unterstützen sind unter folgendem
Link zu finden: \url{https://www.schemastore.org/json/#editors}

\subsubsection{fulibTools}
\todo
Dank fulibTools ist auch fulib mit drin.
FulibTools ist zur Generierung von Objektidiagrammen genutzt worden.
Fulib (Bei FulibTools mit integriert) zur Generierung von Klassendiagrammen.

\subsection{fulibWorkflows Web-Editor FE}\label{subsec:fulibworkflows-web-editor}
\todo
Da brauchte es etwas mehr als beim BE\@.
Die Entscheidungen für die verwendeten Technologien im Frontend wurden aufgrund
der Idee der Integrierung vom Editor auf fulib.org getroffen.

\subsubsection{Angular}
\todo
Wir kennen es.
Wir lieben es.

\subsubsection{Bootstrap}
\todo
Alles für den Dackel, alles für den Club unser Leben für die schön gestylten FEs.
Simpel, oder?
Ja, okay.
Man nutzt dann auch ng-bootstrap für Angular Anwendungen.
Natürlich auch noch bootstrap-icons.
Will ja niemand traurig machen und von Adrian verdroschen werden.

\subsubsection{Codemirror}
\todo
Schönes Ding.
Ngx-codemirror ist es dann speziell für eine Angular Anwendung geworden.
Eigentlich alles out of the box benutzt.

\subsubsection{Angular-split}
\todo
Find ich schon gut zu erwähnen.
Ohne die geile dependency wäre das FE nie so pornös geworden.

\subsubsection{file-saver}
\todo
Weitere erwähnenswerte dependency.
Wird genutzt um Dateien, die vom BE kommen, auch herunterladen zu können.

\subsubsection{ajv}
\todo

\subsubsection{js-yaml}
\todo


\subsection{fulibWorkflows Web-Editor BE}\label{subsubsec:backend}
\todo
Yeey alle Technologien die ich im Backend benutzt habe.

\subsubsection{Spring Boot}
\todo
Framework mit dem man easy mal ein backend generiert bekommt.
Durch Java und viele Dependency allerdings alles andere als ein leichtgewicht.

Dennoch musste ein Java backend her, da sonst fulibWorkflows nicht hätte integriert werden können.
Jedenfalls nicht ohne noch mehr middle ware.

Zudem hatte ich im Praktikum mit Spring Boot Erfahrungen gesammelt.
Die Verwendung von Annotations und dem aufsplitten zwischen Controller und Service ist mir bereits
durch Nest.js bekannt gewesen.

Dennoch muss man sagen, dass durch die von Spring Boot bereits integrierten libraries nichts weiter
außer fulibWorkflows hinzugefügt werden musste.
Immerhin umfasst der Code vom Backend vielleicht 300 Lines of Code.

\subsubsection{fulibWorkflows}
\todo
Sollte mindestens irgendwo erwähnt werden.
Kann man ggf. auch in dem Text zum Kapitel schreiben.

\subsection{Deployment}\label{subsec:deployment}
\todo
Ein Web Editor will natürlich für alle erreichbar sein.
Und fulibWorkflows muss auch irgendwo bereitgestellt werden, damit es das Backend und alle anderen
interessierten benutzen können.

\subsubsection{MavenCentral}\label{subsubsec:mavencentral}
\todo
MavenCentral ein wirklicher Hussarones was das publishen angeht.
Glücklicherweise ist fulibWorkflows Teil der Fujaba Tool Suite, wodurch die benötigten
Zugriffsrechte bereits vorhanden und andere Libraries bereits gepublished wurden.
Hierdurch war es recht schnell möglich mit dem zuvor erworbenem Wissen fulibWorkflows
zu publishen.

\subsubsection{Heroku}\label{subsubsec:heroku}
\todo
Der Web-Editor soll immer erreichbar sein.
Dies ist durch Heroku nur bedingt möglich.
Heroku bietet allerlei Möglichkeiten verschiedenste Anwendungen bereitzustellen.
Auch mit einem kostenlosen Plan ist es ohne Probleme möglich solch kleine Anwendungen bereitzustellen.

FE Deployment war easy, auch wenn ich erstmal wieder in eins meiner früheren Projekte gucken musste.
BE Deployment war kniffliger, doch man ist nie der erste der eine Spring Boot application
auf Heroku deployen will.
Daher Tutorial reingefahren und ab ging der gebutterte Lachs.